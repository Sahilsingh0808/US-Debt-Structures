# -*- coding: utf-8 -*-
"""US_states.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Wf__EHvxV8gfKM8EDU_0t0xC67jNGkvD

Import Sets
"""

import pickle
from os import walk
from pyexpat.errors import codes
from matplotlib import table
import pandas as pd
import os
import re
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import matplotlib.patches as patches
import math
from regex import Match
import tabula

"""Declarations"""

tables = []
index = 0
states = [
    "north_carolina",
    "nevada",
    "illinois",
    "new_mexico",
    "connecticut",
    "colorado",
    "oregon",
    "louisiana",
    "idaho",
    "florida",
    "kansas",
    "california",
    "south_dakota",
    "alabama",
    'massachusetts',
    "oklahoma",
    "north_dakota",
    "tennessee",
    "mississippi",
    "wyoming",
    "michigan",
    "maine",
    "virginia",
    "arkansas",
    "kentucky",
    "indiana",
    "montana",
    "west_virginia",
    "ohio",
    "rhode_island",
    "new_york",
    "utah",
    "delaware",
    "georgia",
    "missouri",
    "maryland",
    "arizona",
    "nebraska",
    "washington",
    'texas',
    "new_hampshire",
    "minnesota",
    "south_carolina",
    "pennsylvania",
    "new_jersey",
    "vermont",
    "wisconsin",
    "district_of_columbia",
    "hawaii",
    "alaska"]
codes = [
    "nc_state_of_north_carolina_",
    "nv_state_of_nevada_",
    "il_state_of_illinois_",
    "nm_state_of_new_mexico_",
    "ct_state_of_connecticut_",
    "co_state_of_colorado_",
    "or_state_of_oregon_",
    "la_state_of_louisiana_",
    "id_state_of_idaho_",
    "fl_state_of_florida_",
    "ks_state_of_kansas_",
    "ca_state_of_california_",
    "sd_state_of_south_dakota_",
    "al_state_of_alabama_",
    "ma_state_of_massachusetts_",
    "ok_state_of_oklahoma_",
    "nd_state_of_north_dakota_",
    "tn_state_of_tennessee_",
    "ms_state_of_mississippi_",
    "wy_state_of_wyoming_",
    "mi_state_of_michigan_",
    "me_state_of_maine_",
    "va_state_of_virginia_",
    "ar_state_of_arkansas_",
    "ky_state_of_kentucky_",
    "in_state_of_indiana_",
    "mt_state_of_montana_",
    "wv_state_of_west_virginia_",
    "oh_state_of_ohio_",
    "ri_state_of_rhode_island_",
    "ny_state_of_new_york_",
    "ut_state_of_utah_",
    "de_state_of_delaware_",
    "ga_state_of_georgia_",
    "mo_state_of_missouri_",
    "md_state_of_maryland_",
    "az_state_of_arizona_",
    "ne_state_of_nebraska_",
    "wa_state_of_washington_",
    "tx_state_of_texas_",
    "nh_state_of_new_hampshire_",
    "mn_state_of_minnesota_",
    "sc_state_of_south_carolina_",
    "pa_state_of_pennsylvania_",
    "nj_state_of_new_jersey_",
    "vt_state_of_vermont_",
    "wi_state_of_wisconsin_",
    "dc_state_of_district_of_columbia_",
    "hi_state_of_hawaii_",
    "ak_state_of_alaska_"]

year = 2018  # change year here
path = "/home/sahilsingh/Documents/oliver/"+str(year)
path1 = "/home/sahilsingh/Dropbox/MigrationData/CAFR_states_output/"
# make a central path
dataCopy = pd.DataFrame()
dataBefore = pd.DataFrame()
tableIDList = []
tableBefore = False
tableIDBefore = ""
indexBefore = 0
idType = []
tableType = []
res = {}
finalData = pd.DataFrame(columns=['Due Year', 'State', 'Table ID',
                         'Table Category', 'Principal', 'Interest', 'Swap Net Payment', 'Total'])

"""***Functions***

Identify Type of Table
"""


def identify_table(tabdata, yr, threshold):

    indexcol = tabdata.iloc[:, 0]
    valuelist = [it for it in indexcol.to_list() if it != ""]
    count = 0
    for ele in valuelist:
        try:
            newele = int(ele)
            # print(newele)
            if newele in list(range(yr, yr+30)):
                count += 1
        except:
            pass

    if len(valuelist) == 1:
        freq = count / (len(valuelist))
    else:
        freq = count / (len(valuelist) - 1)

    d_mattable = freq > threshold
    if d_mattable:
        concatStr = ""
        rowC = tabdata.shape[0]
        colC = len(tabdata.columns)
        for k in range(0, rowC):
            row = tabdata.iloc[k].to_list()
            for l in range(0, len(row)):
                concatStr += str(row[l])+" "
        findPrincipal = re.search(r"principal", concatStr, re.IGNORECASE)
        findInterest = re.search(r"interest", concatStr, re.IGNORECASE)
        if findPrincipal or findInterest:
            return True
        elif not findPrincipal and not findInterest:
            return False
    else:
        return False


"""Table ID"""


def get_table_id(tab):
    table_id = ""
    table = tab[:-4]
    for i in range(0, len(table)-3):
        if table[i] == "_" and table[i+1] == "i" and table[i+2] == "d" and table[i+3] == '_':
            table_id = table[i+1:len(table)-2]
            break
    return table_id


"""Repair df index"""


def repair_dfindex(tabdata):
    try:
        if tabdata.iloc[-1, 0] == "":
            tabdata.iloc[-1, 0] = "total"
        else:
            pass
    except:
        pass

    for idx, row in tabdata.iterrows():

        indexvalue = row.iloc[0]
        indexvalue = indexvalue.strip().lower()
        # print(indexvalue)

        brokenhyphen = re.search("^(\d{4})(\s*)(\d{4})$", indexvalue)

        if brokenhyphen:
            # print(brokenhyphen)
            newvalue = f"{brokenhyphen.group(1)}-{brokenhyphen.group(3)}"
            tabdata.loc[idx,  tabdata.columns[0]] = newvalue

    return tabdata


"""Check for multiple tables in one"""


def multipleTables(data):
    principal = 0
    for col in data.columns:
        if "principal" in str(col).lower():
            principal += 1

    if principal > 1:
        return True
    else:
        return False


"""Get Headings"""


def get_headings(data):
    headings = []
    data_list = data.values.tolist()
    for i in range(0, len(data_list)):
        for j in range(0, len(data_list[i])):
            if "Year" in str(data_list[i][j]) or "year" in str(data_list[i][j]):
                if i == 0:
                    headings = data_list[i]
                else:
                    x = (data_list[i-1])
                    y = (data_list[i])
                    for j in range(0, min(len(x), len(y))):
                        if y[j] != "" and y[j] != "\n":
                            headings.append(x[j]+" "+y[j])

                break
    return headings


"""Check Float"""


def check_float(x):
    try:
        ff = float(x)
        return True
    except ValueError:
        return False


"""Check First Row"""


def check_firstrow(x):
    # do some cleaning
    x = x.replace("$", "").replace("S", "")
    x = x.strip().lower()

    d_empty = x == ""
    d_numeric = check_float(x)

    if d_empty or not d_numeric:
        return True
    else:
        return False


"""Adjust Colheader"""


def adjust_colheaderformat(x):
    x = str(x)
    x = x.strip().lower()
    x = x.replace("-", "").replace(" ", "_").strip('\''',').replace(',', '')
    x = x.replace(r"(", "")
    x = x.replace(r")", "")
    x = x.replace(r"__", "_").replace(r"__", "_")
    return x


"""Final Adj Colheader"""


def finaladj_colheader(x):
    x = re.sub('^\_', '', x)
    x = re.sub('\_$', '', x)
    return x


"""Get Colheader"""


def get_colheader(tabdata, camelot):
    if camelot:
        dflist = tabdata.values.tolist()
    else:
        dflist = [list(tabdata.columns)] + tabdata.values.tolist()

    rowindex = 0

    while check_firstrow(dflist[rowindex][0]) and rowindex < len(dflist):
        rowindex += 1

    if rowindex > 0:
        # print("Multicolumn header")
        newcolsdict = {0: ""}
        for i in range(1, len(tabdata.columns)):
            aux_header = "_".join([adjust_colheaderformat(
                dflist[rowidx][i]) for rowidx in range(rowindex)])

            header = finaladj_colheader(aux_header)

            newcolsdict.update({i:  header})

    else:
        newcolsdict = dict([[idx, adjust_colheaderformat(col)]
                           for idx, col in enumerate(tabdata.columns)])

    return newcolsdict


"""Delete Empty Rows"""


def delete_empty_rows(data):
    data = data.dropna(axis=0, how='all', inplace=True)
    return data


"""Delete Empty Columns"""


def delete_empty_columns(data, headings):
    # rowC=data.shape[0]
    # colC=len(data.columns)
    # for i in range(0,colC):
    #     for j in range(0,rowC):
    #         try:
    #             print(str(data[i][j]))
    #         except:
    #             pass
    cols = data.columns.tolist()
    for i in range(1, len(cols)):
        try:
            column = data[cols[i]]
            # print((column))
            sum = 0.0
            for j in range(0, len(column)):
                try:
                    cell = float(column[j])
                    sum += cell
                except:
                    pass
            if sum == 0.0:
                # print("FOUND EMPTY COLUMN")
                # print(i)
                if "principal" in str(headings[i]).lower() or "interest" in str(headings[i]).lower() or "total" in str(headings[i]).lower() or "swap" in str(headings[i]).lower() or "net" in str(headings[i]).lower():
                    pass
                else:
                    data = data.drop(cols[i], axis=1)
        except:
            pass

        # for j in range(0,len(column)):
        #     sum+=float(column[j])
        # if sum==0.0:
        #     data=data.drop(columns=cols[i])
            # if type(column[j])!=float and type(column[j])!=int:
            #     print(column[j])
    return data


"""Check String"""


def checkString(str1):

    # initializing flag variable
    flag_l = False
    flag_n = False

    # checking for letter and numbers in
    # given string
    for i in str1:

        # if string has letter
        if i.isalpha():
            flag_l = True

        # if string has number
        if i.isdigit():
            flag_n = True

    # returning and of flag
    # for checking required condition
    return flag_l or flag_n


"""Delete Empty Rows Values"""


def delete_empty_rows_values(data):
    data_list = data.values.tolist()
    for i in range(0, len(data_list)):
        if data_list[i] == []:
            try:
                data = data.drop(data.index[i])
            except:
                pass
        elif data_list[i] == [np.nan]:
            try:
                data = data.drop(data.index[i])
            except:
                pass
        cc = 0
        for j in range(0, len(data_list[i])):

            # print(data_list[i][j])
            if checkString(str(data_list[i][j])) == False or data_list[i][j] == "0.0" or data_list[i][j] == "0":
                cc += 1
            # if checkString(str(data_list[i][j]))==False:
            #     data[i][j]="0"

        if cc == (len(data_list[i])-1):
            try:
                data = data.drop(data.index[i])
            except:
                pass
    return data


"""Correct Numbers Table"""


def correct_numbers_table(data):
    rowC = data.shape[0]
    colC = len(data.columns)
    for i in range(1, colC):
        for j in range(0, rowC):
            try:
                cell = str(data[i][j])
                newNum = ""
                for k in cell:
                    if k.isdigit() == True or k == '.':
                        newNum += k
                data[i][j] = newNum
            except:
                print(i, j, "ERR")
                # print(str(data[i][j]))
    return data


"""Interpolate"""


def interpolate(data):
    rowC = data.shape[0]
    colC = len(data.columns)
    data_list = data.values.tolist()
    # print(len(data_list[0]))
    print(len(data_list))
    if data.empty == False:
        for i in range(0, len(data_list[0])):
            for j in range(0, len(data_list)):
                # changing null values to 0
                if data_list[j][i] == '' or data_list[j][i] == '—':
                    data_list[j][i] = 0.0
                # converting string values to numbers
                try:
                    if i > 0:
                        data_list[j][i] = float(data_list[j][i])
                except:
                    print("ERROR "+data_list[j][i])
        data = pd.DataFrame(data_list)
        insertL = [[]]
        for i in range(0, len(data_list)):
            # print(data_list[i])
            year = str(data_list[i][0])
            match = re.match(r'.*([1-3][0-9]{3})', year)
            if match is not None:
                if(len(year) > 7) and ('there' in year) == False and ('\n$' in year) == False:
                    if year[:-3] == '\n$':
                        year = year[0:4]
                        continue
                    years = year.split("‐")
                    if '-' in years[0]:
                        years = years[0].split('-')
                    endY = True
                    starting_year = ""
                    ending_year = ""
                    try:
                        if len(years[1]) == 2:
                            endY = False
                            ending_year = int("20"+years[1])
                    except:
                        pass
                    try:
                        cell1 = str(data_list[i][1])
                        print(int(cell1[0:4]))
                        cell1 = cell1.strip()
                        if int(cell1[0:4]) > 2000 and int(cell1[0:4]) < 2100 and len(cell1)<=5:
                            year += str(cell1[0:4])
                            print("YEAR ADD")
                            print(year)
                    except:
                        pass

                    year.strip()
                    starting_year = int(year[0:4])
                    print(year)
                    if endY == True:
                        ending_year = int(year[len(year)-4:])

                    print(starting_year,ending_year)
                    diff = int(ending_year-starting_year+1)
                    insert_list = []

                    for j in range(1, len(data_list[0])):
                        cell = data_list[i][j]
                        print(cell)
                        # print(cell)
                        insert_list.append(cell/diff)
                    # print(insert_list)

                    for j in range(0, diff):
                        yr = str(starting_year+j)
                        insert_list.insert(0, yr)
                        # print(insert_list)
                        data.loc[len(data)] = insert_list
                        # insertL.append(insert_list)
                        insert_list.pop(0)
                    # print(insertL)
                    insert_list.clear()

        data_list1 = data.values.tolist()
        for i in range(0, len(data_list1)):
            # print(data_list[i])
            year = str(data_list1[i][0])
            if(len(year) > 4):
                # print(year)
                data = data.drop(index=i)

        # print(data_list)

        # for i in range(0,rowC):
        #     year=str(data[0][i])
        #     print(year)
        #     if(len(year)>4):
        #         years=year.split("-")
        #         starting_year=int(years[0])
        #         ending_year=int(years[1])
        #         diff=ending_year-starting_year+1
        #         insert_list=[]
        #         for j in range(1,colC):
        #             # if re.match(r'^-?\d+(?:\.\d+)$', data[i][j]) is None:
        #             #     print ("Not float")
        #             # else:
        #             #     insert_list.append(data[i][j]/diff)
        #             try:
        #                 print((data[i][j]))
        #                 insert_list.append(int(data[i][j])/diff)
        #             except:
        #                 pass
        #         print(insert_list)

    return data


"""Delete Empty Columns Extra"""


def delete_empty_columns_extra(data, extra):
    cc = 0
    # rowC=data.shape[0]
    # colC=len(data.columns)
    # for i in range(0,colC):
    #     for j in range(0,rowC):
    #         try:
    #             print(str(data[i][j]))
    #         except:
    #             pass
    cols = data.columns.tolist()
    for i in range(1, len(cols)):
        try:
            column = data[cols[i]]
            # print((column))
            sum = 0.0
            for j in range(0, len(column)):
                try:
                    cell = float(column[j])
                    sum += cell
                except:
                    pass
            if sum == 0.0 and cc < extra:
                # print("FOUND EMPTY COLUMN")
                # print(i)
                cc += 1
                data = data.drop(cols[i], axis=1)
        except:
            pass

        # for j in range(0,len(column)):
        #     sum+=float(column[j])
        # if sum==0.0:
        #     data=data.drop(columns=cols[i])
            # if type(column[j])!=float and type(column[j])!=int:
            #     print(column[j])
    return data


"""Format Headings"""


def format_headings(headings):

    for i in range(0, len(headings)):
        headings[i] = headings[i].replace("_", " ")
        headings[i] = headings[i].replace("/", " ")
        headings[i] = headings[i].replace("\\", " ")
        headings[i].strip()

        headings[i] = headings[i].lower()
        if "principal" in headings[i]:
            headings[i] = "Principal"
        elif "swap" in headings[i]:
            headings[i] = "Swap Net Payment"
        elif "interest" in headings[i]:
            headings[i] = "Interest"
        elif "total" in headings[i]:
            headings[i] = "Total"
        elif "operating leases" in headings[i]:
            headings[i] = "Total"

    if(len(headings) == 0):
        headings.append("Due Year")
    else:
        headings[0] = "Due Year"

    return headings


"""Format Headings"""


def tableCategory(data, newcolsdict, headings, numberTables, tableBefore, dataBefore, loc):
    newcolsdict = zip(newcolsdict.values())
    newcolsdict = list(newcolsdict)
    newcolsdict = [''.join(i) for i in newcolsdict]
    first = newcolsdict[0]
    category = ''
    print(headings)
    print("HEADINGS")

    if tableBefore == True:
        df = dataBefore.to_string()
        df = df.lower()
        general = df.find("general")
        revenue = df.find("revenue")
        operating = df.find("operating")
        capital = df.find("capital")
        certificates = df.find("certificates")
        components = df.find("components")
        debt = df.find("debt")
        if general != -1:
            category = "General Obligation Bonds"
        elif revenue != -1:
            category = "Revenue Bonds"
        elif operating != -1:
            category = "Operating Leases"
        elif capital != -1:
            category = "Capital Leases"
        elif certificates != -1:
            category = "Certificates of Participation"
        elif components != -1:
            category = "Components Units"
        elif debt != -1:
            category = "Debt Service Requirements"

    for i in range(len(headings)):
        con = headings[i].lower()
        general = con.find("general")
        revenue = con.find("revenue")
        operating = con.find("operating")
        capital = con.find("capital")
        certificates = con.find("certificates")
        components = con.find("components")
        debt = con.find("debt")
        if general != -1:
            category = "General Obligation Bonds"
        elif revenue != -1:
            category = "Revenue Bonds"
        elif operating != -1:
            category = "Operating Leases"
        elif capital != -1:
            category = "Capital Leases"
        elif certificates != -1:
            category = "Certificates of Participation"
        elif components != -1:
            category = "Components Units"
        elif debt != -1:
            category = "Debt Service Requirements"

    for i in range(len(newcolsdict)):
        try:
            fir = newcolsdict[i].lower()
            if "principal" in fir:
                del newcolsdict[i]
            elif "interest" in fir:
                del newcolsdict[i]
            elif "total" in fir:
                del newcolsdict[i]
            elif "swap net payment" in fir:
                del newcolsdict[i]
        except:
            print("ERROR")
    print(newcolsdict)

    if numberTables == 1:
        df = data.to_string()
        df = df.lower()
        general = df.find("general")
        revenue = df.find("revenue")
        operating = df.find("operating")
        capital = df.find("capital")
        certificates = df.find("certificates")
        components = df.find("components")
        debt = df.find("debt")
        if general != -1:
            category = "General Obligation Bonds"
        elif revenue != -1:
            category = "Revenue Bonds"
        elif operating != -1:
            category = "Operating Leases"
        elif capital != -1:
            category = "Capital Leases"
        elif certificates != -1:
            category = "Certificates of Participation"
        elif components != -1:
            category = "Components Units"
        elif debt != -1:
            category = "Debt Service Requirements"

        if category == "":
            for i in range(len(newcolsdict)):
                if newcolsdict[i] != '':
                    category = newcolsdict[i]

    else:
        j = 0
        x = ""
        for i in range(len(newcolsdict)):
            if newcolsdict[i] != '' and len(newcolsdict[i]) > 4:
                if loc == i:
                    category1 = newcolsdict[i]
                    x = category1
                    general = category1.find("general")
                    revenue = category1.find("revenue")
                    operating = category1.find("operating")
                    capital = category1.find("capital")
                    certificates = category1.find("certificates")
                    components = category1.find("components")
                    if general != -1:
                        category = "General Obligation Bonds"
                    elif revenue != -1:
                        category = "Revenue Bonds"
                    elif operating != -1:
                        category = "Operating Leases"
                    elif capital != -1:
                        category = "Capital Leases"
                    elif certificates != -1:
                        category = "Certificates of Participation"
                    elif components != -1:
                        category = "Components Units"
                j += 1
        if category == '':
            if x != '':
                category = x
            else:
                category = first
    if category == '':
        category = "Not Available"
    return category

"""Check Multiple Dots Data"""


def checkMultipleDots(data):
    check=False
    rowC = data.shape[0]
    colC = len(data.columns)
    list1=[]
    list2=[]
    idx=0
    for i in range(1, colC):
        for j in range(0, rowC):
            try:
                cell = str(data[i][j])
                if cell.count('.')==2:
                    check=True
                    idx=i
                    cells=cell.split('.')
                    f=cells[0]
                    s=cells[1]
                    t=cells[2]
                    res_first = s[0:len(s)//2]
                    res_second = s[len(s)-len(s)//2-1:]
                    f+='.'+res_first
                    t=res_second+'.'+t
                    list1.append(f)
                    list2.append(t)
    
            except:
                pass
    print(list1)
    print(list2)
    if len(list1)>0:
        print(idx)
        cols=data.columns.values.tolist()
        cols.append((int(cols[-1]+1)))
        print(cols)
        data = data.drop(data.columns[i-1],axis = 1)
        data.insert(i,'a',list1)
        data.insert(i+1,'b',list2)
        data.columns=cols
    print(data)
    return data


"""Check Multiple Year Data"""


def checkYearMultiple(data):
    check = True
    data_list = data.values.tolist()
    for i in range(0, len(data_list)):
        year = str(data_list[i][0])
        match = re.match(r'.*([1-3][0-9]{3})', year)
        if match is not None:
            if len(year) < 10  or ('\n' in year == False):
                check = False
                break
    print(check)
    if check == True:
        data_list = data.values.tolist()
        years = []
        amount = []
        for i in range(0, len(data_list)):
            year = str(data_list[i][0])
            match = re.match(r'.*([1-3][0-9]{3})', year)
            if match is not None:
                aa = year.split('\n')
                print(aa)
                years.append(str(aa[0]).strip())
                amount.append(str(aa[-1]).strip())
        print(years)
        print(amount)
        for ii in range(len(amount)):
            am=str(amount[ii])
            am=am.replace(",","")
            print(am)
            amount[ii]=int(float(am))
        data = data.iloc[: , 2:]
        data.insert(0, '1', amount)
        data.insert(0,'0',years)
        data = delete_empty_rows_values(data)
        data = correct_numbers_table(data)
        data = correct_numbers_table(data)
        print(data)
    return data


"""Extract State Name from Filename"""


def extractStateName(filename):
    arr = filename.split("_")
    arr = arr[3:-5]
    state = ""
    for i in range(len(arr)):
        if i > 0:
            state += "_"+arr[i]
        else:
            state += arr[i]
    return state


"""Filenames"""

filenames = next(walk(
    r''+path1+str(year)+'/dataout/'), (None, None, []))[2]
print(len(filenames))
filenamesCopy = filenames.copy()
# for i in range(len(filenames)):
#     print(filenames[i])

"""Restricting to a particular state"""
for ll in range(len(states)):
    filenames = filenamesCopy.copy()
    print(len(states), len(codes))
    state = states[ll]
    code = codes[ll]
    print(state, code)
    for i in range(0, len(filenames)):
        try:
            filenameState = extractStateName(filenames[i])
            # print(filenameState)
            if state == filenameState:
                continue
            else:
                filenames[i] = None
        except:
            pass
    filenames = list(filter(None, filenames))
    print(len(filenames))

    """Final Algorithm"""

    for i in range(len(filenames)):
        with open(f''+path1+str(year)+'/dataout/'+filenames[i], 'rb') as f:
            data = pickle.load(f)
            table_id = get_table_id(filenames[i])
            tableIDList.append(table_id)
            tables.append(data)
            # filenames1 = next(walk(
            #     r'home/sahilsingh/Dropbox/MigrationData/CAFR_states_output/'+str(year)+'/doc'), (None, None, []))[2]
            # doc=""
            # print(filenames1)
            # for j in range(len(filenames1)):
            #     if state in filenames1[j]:
            #         doc = filenames1[j]
            #         break
            # print(doc)vC
            with open(f''+path1+str(year)+'/doc/'+codes[ll]+str(year)+'_tabledirectory.pkl', 'rb') as f:
                data1 = pickle.load(f)
                idType = data1['id'].to_list()
                tableType = data1['type'].to_list()
                for key in idType:
                    for value in tableType:
                        res[key] = value
                        tableType.remove(value)
                        break
            d_mattable = identify_table(data, year, threshold=.2)
            filename_array = filenames[i].split("_")
            # print(filename_array)
            filename_array[3] = filename_array[3].capitalize()
            filename_temp = filename_array[:-4]
            filename_templ = ""
            for i in filename_temp:
                filename_templ += i+"_"
            if (filename_array[4])[0] == "2":
                state = filename_array[3]
            else:
                filename_array[4] = filename_array[4].capitalize()
                state = filename_array[3]+" "+filename_array[4]
            if d_mattable:
                if tableIDList.index(table_id) > 0:
                    indexBefore = idType.index(table_id)+1
                    tableIDBefore = idType[indexBefore]
                    tableTypeBefore = res[tableIDBefore]
                    if tableTypeBefore == 'title':
                        tableBefore = True
                    else:
                        tableBefore = False
                    filename_templ += tableIDBefore+"_c.pkl"
                    filename_templ = filename_templ.lower()
                    with open(f""+path1+str(year)+"/dataout/"+filename_templ, 'rb') as f:
                        dataBefore = pickle.load(f)
                    # print(tableIDBefore)

                # repair index
                data = repair_dfindex(data)
                print(data)

                dataCopy = data

                # column headers
                headings = get_headings(data)

                newcolsdict = get_colheader(data, camelot=True)

                # print(data)
                print(newcolsdict)
                print(table_id)

                # print whole table
                with pd.option_context('display.max_rows', None, 'display.max_columns', None):

                    numberTables = 0
                    # delete a completely empty row
                    delete_empty_rows(data)
                    rowC = data.shape[0]
                    colC = len(data.columns)
                    data_list = data.values.tolist()
                    print(data)
                    startingFound = False
                    # ignoring the starting useless rows of the dataframe
                    for i in range(0, len(data_list)):
                        for j in range(0, len(data_list[i])):
                            cell = str(data_list[i][0])
                            if cell[:-3] == '\n$':
                                cell = cell[0:4]
                                continue
                            match = re.match(r'.*([1-3][0-9]{3})', cell)

                            if match is not None:
                                # print(match.group(1))
                                # if "Year" in cell or "year" in cell:
                                data = (data.iloc[i:, ])
                                startingFound = True
                                # print(data)
                                break
                        if startingFound == True:
                            break
                    # print(data)
                    data = repair_dfindex(data)
                    data = data.reset_index(drop=True)
                    # print(data)
                    # ignoring the ending useless rows of the dataframe
                    data_list = data.values.tolist()
                    for i in range(0, len(data_list)):
                        for j in range(0, len(data_list[i])):
                            cell = str(data_list[i][j])
                            if "Total" in cell or "total" in cell or "Less:" in cell:
                                data = (data.iloc[:i, ])
                                break
                    # print(data)
                    data = delete_empty_rows_values(data)
                    # print(data)
                    for i in range(0, len(data.columns)):
                        for j in range(0, data.shape[0]):
                            try:
                                cell = (data[i][j])
                                if(pd.isnull(cell)) or cell == '\n':
                                    data[i][j] = np.nan
                                if ord(cell) == 8212 or ord(cell) == 36:
                                    data[i][j] = np.nan
                            except:
                                pass
                    print(data)
                    data = correct_numbers_table(data)
                    print(data)
                    data = checkYearMultiple(data)
                    data= checkMultipleDots(data)
                    data = interpolate(data)

                    # mattype=[]
                    # for i in range(0,data.shape[0]):
                    #     mattype.append("year")
                    # data["mattype"]=mattype

                    # convert entries to float
                    data = data.astype(float)

                    # format headings name

                    # if newcolsdict[0]=="":
                    #     newcolsdict[0]="Year"
                    # x=newcolsdict.values()
                    # data.columns=list(x)

                    principalCount = 0
                    interestCount = 0
                    totalCount = 0
                    otherCount = 0
                    swapCount = 0

                    principalIndex = []
                    interestIndex = []
                    totalIndex = []
                    otherIndex = []
                    swapIndex = []

                    data = delete_empty_columns(data, headings)

                    while("" in headings):
                        headings.remove("")

                    headingsRaw = headings.copy()

                    for i in range(0, len(headings)):
                        head = str(headings[i])
                        head = head.lower()
                        if head == "" or head == "\n":
                            continue
                        elif "principal" in head:
                            principalCount += 1
                            principalIndex.append(i)
                        elif "interest" in head:
                            interestCount += 1
                            interestIndex.append(i)
                        elif "total" in head:
                            totalCount += 1
                            totalIndex.append(i)
                        elif "swap" in head or "net" in head:
                            swapCount += 1
                            swapIndex.append(i)
                        else:
                            otherCount += 1
                            otherIndex.append(i)

                    columnCount = principalCount+interestCount+totalCount+otherCount+swapCount
                    if(len(data.columns) == columnCount):
                        print("MATCHES")
                    else:
                        extra = len(data.columns)-columnCount
                        data = delete_empty_columns_extra(data, extra)
                    print(len(data.columns))
                    print(principalCount, interestCount,
                          swapCount, totalCount, otherCount)

                    headings = format_headings(headings)
                    print(headings)
                    print("FORMATTED HEADINGS")

                    if(len(data.columns) == columnCount):
                        data.columns = headings

                    yearsCol = data.iloc[:, 0]

                    principalInd = []
                    for i in range(0, len(headings)):
                        if "Principal" in headings[i]:
                            principalInd.append(i)

                    print(principalInd)

                    data = data.iloc[:, 1:]

                    if len(principalInd) == 1:
                        x = data.iloc[:, :principalInd[0]-1]
                        y = data.iloc[:, principalInd[0]-1:]
                        if(x.empty == False):
                            numberTables += 1
                        if(y.empty == False):
                            numberTables += 1

                        if x.empty == False:
                            table_category = tableCategory(
                                data, newcolsdict, headingsRaw, numberTables, tableBefore, dataBefore, 0)
                            x.insert(loc=0, column='Due Year', value=yearsCol)
                            x.insert(loc=0, column='State', value=state)
                            x.insert(loc=0, column='Table ID', value=table_id)
                            x.insert(loc=0, column='Table Category',
                                     value=table_category)
                            print(x)
                            if(multipleTables(data) == False):
                                finalData = pd.concat((finalData, x), axis=0)
                            print(table_category)
                            print(numberTables)

                            print("FINAL DATA")
                        if y.empty == False:
                            table_category = tableCategory(
                                data, newcolsdict, headingsRaw, numberTables, tableBefore, dataBefore, 1)
                            y.insert(loc=0, column='Due Year', value=yearsCol)
                            y.insert(loc=0, column='State', value=state)
                            y.insert(loc=0, column='Table ID', value=table_id)
                            y.insert(loc=0, column='Table Category',
                                     value=table_category)
                            print(table_category)
                            print(numberTables)
                            if(multipleTables(data) == False):
                                finalData = pd.concat((finalData, y), axis=0)
                            print(y)

                    else:
                        for i in range(0, len(principalInd)-1):
                            a = principalInd[i]
                            b = principalInd[i+1]
                            x = data.iloc[:, :a-1]
                            y = data.iloc[:, a-1:b-1]
                            z = data.iloc[:, principalInd[-1]-1:]
                            if(x.empty == False):
                                numberTables += 1
                            if(y.empty == False):
                                numberTables += 1
                            if (z.empty == False):
                                numberTables += 1

                            if x.empty == False:
                                table_category = tableCategory(
                                    data, newcolsdict, headingsRaw, numberTables, tableBefore, dataBefore, 0)
                                x.insert(loc=0, column='Due Year',
                                         value=yearsCol)
                                x.insert(loc=0, column='State', value=state)
                                x.insert(loc=0, column='Table ID',
                                         value=table_id)
                                x.insert(loc=0, column='Table Category',
                                         value=table_category)

                                print(table_category)
                                print(numberTables)
                                print(x)
                                if(multipleTables(data) == False):
                                    finalData = pd.concat(
                                        (finalData, x), axis=0)

                            if y.empty == False:
                                table_category = tableCategory(
                                    data, newcolsdict, headingsRaw, numberTables, tableBefore, dataBefore, 1)
                                y.insert(loc=0, column='Due Year',
                                         value=yearsCol)
                                y.insert(loc=0, column='State', value=state)
                                y.insert(loc=0, column='Table ID',
                                         value=table_id)
                                y.insert(loc=0, column='Table Category',
                                         value=table_category)
                                print(table_category)
                                print(numberTables)
                                if(multipleTables(data) == False):
                                    finalData = pd.concat(
                                        (finalData, y), axis=0)
                                print(y)

                            if z.empty == False:
                                table_category = tableCategory(
                                    data, newcolsdict, headingsRaw, numberTables, tableBefore, dataBefore, 2)
                                z.insert(loc=0, column='Due Year',
                                         value=yearsCol)
                                z.insert(loc=0, column='State', value=state)
                                z.insert(loc=0, column='Table ID',
                                         value=table_id)
                                z.insert(loc=0, column='Table Category',
                                         value=table_category)
                                print(table_category)
                                print(numberTables)
                                if(multipleTables(data) == False):
                                    finalData = pd.concat(
                                        (finalData, z), axis=0)
                                numberTables += 1
                                print(z)

    print(finalData)
    finalData = finalData.fillna(0)
    finalData = finalData.reset_index(drop=True)
    finalData.index = range(1, len(finalData)+1)
    finalData.to_excel(path1+str(year)+state+".xlsx")
